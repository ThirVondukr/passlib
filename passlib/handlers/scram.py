"""passlib.handlers.scram - SCRAM hash

Notes
=====
Working on hash to format to support storing SCRAM protocol information
server-side.

passlib issue - https://code.google.com/p/passlib/issues/detail?id=23

scram protocol - http://tools.ietf.org/html/rfc5802
                 http://tools.ietf.org/html/rfc5803

"""
#=========================================================
#imports
#=========================================================
#core
from binascii import hexlify, unhexlify
from base64 import b64encode, b64decode
import re
import logging; log = logging.getLogger(__name__)
from warnings import warn
#site
#libs
from passlib.utils import adapted_b64_encode, adapted_b64_decode, \
        handlers as uh, to_native_str, to_unicode, bytes, b, consteq
from passlib.utils.compat import unicode, bytes, u, b
from passlib.utils.pbkdf2 import pbkdf2, get_prf
#pkg
#local
__all__ = [
    "scram",
]

def test_reference_scram():
    "quick hack testing scram reference vectors"
    from passlib.utils import xor_bytes
    from passlib.utils.pbkdf2 import pbkdf2, get_prf
    from hashlib import sha1

    # NOTE: "n,," is GS2 header - see https://tools.ietf.org/html/rfc5801

    digest = "sha1"
    salt = 'QSXCR+Q6sek8bf92'.decode("base64")
    rounds = 4096
    username = "user"
    password = "pencil"
    client_nonce = "fyko+d2lbbFgONRv9qkxdawL"
    server_nonce = "3rfcNHYJY1ZVvWVs7j"

    # hash passwd
    hk = pbkdf2(password, salt, rounds, 20, prf="hmac-" + digest)

    # auth msg
    auth_msg = (
        'n={username},r={client_nonce}'
            ','
        'r={client_nonce}{server_nonce},s={salt},i={rounds}'
            ','
        'c=biws,r={client_nonce}{server_nonce}'
        ).format(salt=salt.encode("base64").rstrip(), rounds=rounds,
                 client_nonce=client_nonce, server_nonce=server_nonce,
                 username=username)

    # client proof
    hmac, hmac_size = get_prf("hmac-" + digest)
    ck = hmac(hk, "Client Key")
    cs = hmac(sha1(ck).digest(), auth_msg)
    cp = xor_bytes(ck, cs).encode("base64").rstrip()
    assert cp == "v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=", cp

    # server proof
    sk = hmac(hk, "Server Key")
    ss = hmac(sk, auth_msg).encode("base64").rstrip()
    assert ss == "rmF9pqV8S7suAoZWja4dJRkFsKQ=", ss

# TODO: norm_digest_name(), stringprep()

#=========================================================
#
#=========================================================
class scram(uh.HasRounds, uh.HasRawSalt, uh.HasRawChecksum, uh.GenericHandler):
    "base class for various pbkdf2_{digest} algorithms"
    ##    __doc__="""This class implements a generic ``PBKDF2-%(prf)s``-based password hash, and follows the :ref:`password-hash-api`.
    ##
    ##It supports a variable-length salt, and a variable number of rounds.
    ##
    ##The :meth:`encrypt()` and :meth:`genconfig` methods accept the following optional keywords:
    ##
    ##:param salt:
    ##    Optional salt bytes.
    ##    If specified, the length must be between 0-1024 bytes.
    ##    If not specified, a %(dsc)d byte salt will be autogenerated (this is recommended).
    ##
    ##:param salt_size:
    ##    Optional number of bytes to use when autogenerating new salts.
    ##    Defaults to 16 bytes, but can be any value between 0 and 1024.
    ##
    ##:param rounds:
    ##    Optional number of rounds to use.
    ##    Defaults to %(dr)d, but must be within ``range(1,1<<32)``.

    #=========================================================
    #class attrs
    #=========================================================

    # NOTE: unlike most GenericHandler classes, the 'checksum' attr of
    # ScramHandler is actually a map from digest_name -> digest, so
    # many of the standard methods have been overridden.

    # XXX: how to name digest list? "digest_names", "digests" ?

    # NOTE: max_salt_size and max_rounds are arbitrarily chosen to provide
    # a sanity check; the underlying pbkdf2 specifies no bounds for either.

    #--GenericHandler--
    name = "scram"
    setting_kwds = ("salt", "salt_size", "rounds", "digest_names")
    checksum_chars = uh.H64_CHARS
    ident = u("$scram$")

    #--HasSalt--
    default_salt_size = 12
    min_salt_size = 0
    max_salt_size = 1024

    #--HasRounds--
    default_rounds = 6400
    min_rounds = 1
    max_rounds = 2**32-1
    rounds_cost = "linear"

    #=========================================================
    # scram-specific class methods
    #=========================================================
    @classmethod
    def extract_digest_info(cls, hash, digest_name):
        """given scram hash & negotiated digest, returns ``(salt,rounds,digest)``.

        :arg hash: scram-format hash stored for desired user
        :arg digest_name: name of digest (eg ``SHA-1``) requested by client.

        :raises LookupError:
            If the hash does not contain a key derived from the password
            using the requested digest.

        :returns:
            a tuple containing ``(salt,rounds,digest)``;
            corresponding to (respectively) the *salt*, *iteration count*,
            and *SaltedPassword* required by the SCRAM protocol.
        """
        self = cls.from_string(hash)
        digest_name = normalize_digest_name(digest_name)
        return self.checksums[digest_name]

    @classmethod
    def extract_digest_names(cls, hash):
        """given scran hash, return names of all digests that have
        been calculated for the stored password (e.g. ``["SHA-1"]``)
        """
        self = cls.from_string(hash)
        return self.digest_names

    @classmethod
    def derive_digest(cls, password, salt, rounds, digest_name):
        """helper to create SaltedPassword digest for SCRAM.

        This performs the step in the SCRAM protocol described as::

            SaltedPassword  := Hi(Normalize(password), salt, i)

        :arg password: unicode password
        :arg salt: raw salt bytes, or base64 encoded salt
        :arg rounds: number of iteration
        :arg digest_name: SCRAM-compatible name of digest (e.g. ``SHA-1``).

        :returns:
            raw bytes of SaltedPassword
        """
        password = stringprep(password).encode("utf-8")
        if isinstance(salt, unicode):
            salt = salt.decode("base64")
        elif not isinstance(salt, bytes):
            raise TypeError("salt must be base64-unicode or bytes")
        return pbkdf2(password, salt, rounds, "HMAC-" + digest_name)

    #=========================================================
    #methods
    #=========================================================

    # TODO: add deprecate hooks allowing auto-upgrade
    # when digest_names is changed in context.

    # TODO: add 'digests' keyword to let encrypt() specific
    # which digests should be supported.

    # scram hash format:
    # $scram$<rounds>$<salt>$<digest-name>=<digest-contents>,...

    @classmethod
    def from_string(cls, hash):
        if not hash:
            raise ValueError("no hash specified")
        rounds, salt, chk = uh.parse_mc3(hash, cls.ident, cls.name)
        int_rounds = int(rounds)
        if rounds != unicode(int_rounds): #forbid zero padding, etc.
            raise ValueError("invalid %s hash" % (cls.name,))
        raw_salt = adapted_b64_decode(salt.encode("ascii"))
        if chk:
            chkmap = {}
            for part in chk.rstrip(u(",")).split(u(",")):
                name, digest = part.split(u("="))
                name = normalize_digest_name(name)
                chkmap[name] = adapted_b64_decode(digest)
        else:
            chkmap = None
        return cls(
            rounds=int_rounds,
            salt=raw_salt,
            checksum=chkmap,
            strict=bool(chk),
        )

    def to_string(self, withchk=True):
        salt = adapted_b64_encode(self.salt).decode("ascii")
        if withchk and self.checksum:
            chkmap = self.checksum
            chk = u(',').join(
                u("%s=%s") % (name.lower(), adapted_b64_encode(chkmap[name]))
                for name in sorted(chkmap)
            )
            hash = u('%s%d$%s$%s') % (self.ident, self.rounds, salt, chk)
        else:
            hash = u('%s%d$%s') % (self.ident, self.rounds, salt)
        return to_native_str(hash)

    def calc_checksum(self, secret):
        rounds = self.rounds
        salt = self.salt
        func = self.derive_digest
        return dict(
            (name, func(secret, salt, rounds, name))
            for name in self.digest_names
        )

    #=========================================================
    # overridden standard methods
    #=========================================================
    @classmethod
    def norm_checksum(cls, checksum, strict=False):
        # TODO: wrap orig norm_checksum to handle checksum being a dict.
        raise NotImplementedError

    @classmethod
    def verify(cls, secret, hash, full=False):
        self = cls.from_string(hash)
        chkmap = self.checksum
        if not chkmap:
            return False

        # NOTE: to make the verify method efficient, we just calculate hash
        # of shortest digest by default. apps can pass in "full=True" to
        # check entire hash for consistency.
        if full:
            other = self.calc_checksum(secret)
            correct = failed = False
            for name, value in chkmap.iteritems():
                if consteq(other[name], value):
                    correct = True
                else:
                    failed = True
            if correct and failed:
                warning("scram hash compared inconsistently, may be corrupted")
                return False
            else:
                return correct
        else:
            def sk(item):
                return len(item[1]), item[0]
            name, value = min(chkmap.iteritems(), key=sk)
            other = self.derive_digest(secret, self.salt, self.rounds, name)
            return consteq(other, value)

    #=========================================================
    #
    #=========================================================

#=========================================================
#eof
#=========================================================
